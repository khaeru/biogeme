//-*-c++-*------------------------------------------------------------
//
// File name : patParserParam.y
// File automatically generated by ./automaticParser
// Michel Bierlaire, EPFL
// Date :      Sun Aug  3 09:53:14 2008
//
//--------------------------------------------------------------------
//

%name patBisonParam
%define ERROR_BODY = 0
%define LEX_BODY = 0

%define MEMBERS patScannerParam scanner; patParameters *pParameters; virtual ~patBisonParam() {};
%define CONSTRUCTOR_PARAM const string& fname_
%define CONSTRUCTOR_INIT : scanner(fname_) , pParameters(NULL)

%header{
  
#include <fstream>
#include <sstream>

#include "patDisplay.h"
#include "patParameters.h"

#undef yyFlexLexer
#define yyFlexLexer patFlexParam
#include <FlexLexer.h>
#include "patConst.h"

class patScannerParam : public patFlexParam {

private:
                                    // filename to be scanned
  string _filename;

public:
                                    // void ctor
  patScannerParam()
    : patFlexParam() {
  }
                                    // ctor with filename argument
  patScannerParam(const string& fname_)
    : patFlexParam(), _filename( fname_ )  {
    ifstream *is = new ifstream( fname_.c_str() ); 
    if ( !is || (*is).fail() ) {
      cerr << "Error:: cannot open input file <";
      cerr << fname_ << ">" << endl;
      exit( 1 );
    }
    else {
      switch_streams( is, 0 );
    }
  }
                                    // dtor

  ~patScannerParam() { delete yyin; }

                                    // utility functions

  const string& filename() const { return _filename; }

  string removeDelimeters( const string deli="\"\"" ) {
    
    string str = YYText();
    string::size_type carret = str.find("\n") ;
    if (carret < str.size()) str.erase(carret) ;
    string::size_type deb = str.find( deli[0] ) ;
    if (deb == str.size()) {
      return ( str ) ;
    }
    str.erase( deb , 1 );
    
    string::size_type fin = str.find( deli[1] ) ;
    if (fin >= str.size()) {
      WARNING("Unmatched delimiters (" << filename() << ":" << 
	      lineno() << ") ") ;
      return( str ) ;
    }
    str.erase( fin , 1 );
    return ( str );
  }

  string value() {
    string str = YYText() ;
    return str; 
  }

  // char* value() { return (char*) YYText(); }

  void errorQuit( int err ) {
    cout << "Error = " << err << endl;
    if ( err == 0 ) return;
    cerr << "Problem in parsing"
	 << " (" << filename() << ":" << lineno() << ") "
	 << "Field: <" << YYText() << ">" << endl;
    if ( err < 0 ) exit( 1 );
  }
};



%}

// *** Declare here all data types that will be read by the parser

%union {
  long        itype;
  float       ftype;
  string*     stype;
}

%token pat_BasicTrustRegionSection
%token pat_BTRMaxGcpIter    
%token pat_BTRArmijoBeta1    
%token pat_BTRArmijoBeta2    
%token pat_BTRStartDraws    
%token pat_BTRIncreaseDraws    
%token pat_BTREta1    
%token pat_BTREta2    
%token pat_BTRGamma1    
%token pat_BTRGamma2    
%token pat_BTRInitRadius    
%token pat_BTRIncreaseTRRadius    
%token pat_BTRUnfeasibleCGIterations    
%token pat_BTRForceExactHessianIfMnl    
%token pat_BTRExactHessian    
%token pat_BTRCheapHessian    
%token pat_BTRQuasiNewtonUpdate    
%token pat_BTRInitQuasiNewtonWithTrueHessian    
%token pat_BTRInitQuasiNewtonWithBHHH    
%token pat_BTRMaxIter    
%token pat_BTRTypf    
%token pat_BTRTolerance    
%token pat_BTRMaxTRRadius    
%token pat_BTRMinTRRadius    
%token pat_BTRUsePreconditioner    
%token pat_BTRSingularityThreshold    
%token pat_BTRKappaEpp    
%token pat_BTRKappaLbs    
%token pat_BTRKappaUbs    
%token pat_BTRKappaFrd    
%token pat_BTRSignificantDigits    
%token pat_CondTrustRegionSection
%token pat_CTRAETA0    
%token pat_CTRAETA1    
%token pat_CTRAETA2    
%token pat_CTRAGAMMA1    
%token pat_CTRAGAMMA2    
%token pat_CTRAEPSILONC    
%token pat_CTRAALPHA    
%token pat_CTRAMU    
%token pat_CTRAMAXNBRFUNCTEVAL    
%token pat_CTRAMAXLENGTH    
%token pat_CTRAMAXDATA    
%token pat_CTRANBROFBESTPTS    
%token pat_CTRAPOWER    
%token pat_CTRAMAXRAD    
%token pat_CTRAMINRAD    
%token pat_CTRAUPPERBOUND    
%token pat_CTRALOWERBOUND    
%token pat_CTRAGAMMA3    
%token pat_CTRAGAMMA4    
%token pat_CTRACOEFVALID    
%token pat_CTRACOEFGEN    
%token pat_CTRAEPSERROR    
%token pat_CTRAEPSPOINT    
%token pat_CTRACOEFNORM    
%token pat_CTRAMINSTEP    
%token pat_CTRAMINPIVOTVALUE    
%token pat_CTRAGOODPIVOTVALUE    
%token pat_CTRAFINEPS    
%token pat_CTRAFINEPSREL    
%token pat_CTRACHECKEPS    
%token pat_CTRACHECKTESTEPS    
%token pat_CTRACHECKTESTEPSREL    
%token pat_CTRAVALMINGAUSS    
%token pat_CTRAFACTOFPOND    
%token pat_ConjugateGradientSection
%token pat_Precond    
%token pat_Epsilon    
%token pat_CondLimit    
%token pat_PrecResidu    
%token pat_MaxCGIter    
%token pat_TolSchnabelEskow    
%token pat_DefaultValuesSection
%token pat_MaxIter    
%token pat_InitStep    
%token pat_MinStep    
%token pat_MaxEval    
%token pat_NbrRun    
%token pat_MaxStep    
%token pat_AlphaProba    
%token pat_StepReduc    
%token pat_StepIncr    
%token pat_ExpectedImprovement    
%token pat_AllowPremUnsucc    
%token pat_PrematureStart    
%token pat_PrematureStep    
%token pat_MaxUnsuccIter    
%token pat_NormWeight    
%token pat_FilesSection
%token pat_InputDirectory    
%token pat_OutputDirectory    
%token pat_TmpDirectory    
%token pat_FunctionEvalExec    
%token pat_jonSimulator    
%token pat_CandidateFile    
%token pat_ResultFile    
%token pat_OutsifFile    
%token pat_LogFile    
%token pat_ProblemsFile    
%token pat_MITSIMorigin    
%token pat_MITSIMinformation    
%token pat_MITSIMtravelTime    
%token pat_MITSIMexec    
%token pat_Formule1Section
%token pat_AugmentationStep    
%token pat_ReductionStep    
%token pat_SubSpaceMaxIter    
%token pat_SubSpaceConsecutiveFailure    
%token pat_WarmUpnbre    
%token pat_GEVSection
%token pat_gevInputDirectory    
%token pat_gevOutputDirectory    
%token pat_gevWorkingDirectory    
%token pat_gevSignificantDigitsParameters    
%token pat_gevDecimalDigitsTTest    
%token pat_gevDecimalDigitsStats    
%token pat_gevForceScientificNotation    
%token pat_gevSingularValueThreshold    
%token pat_gevPrintVarCovarAsList    
%token pat_gevPrintVarCovarAsMatrix    
%token pat_gevPrintPValue    
%token pat_gevNumberOfThreads    
%token pat_gevSaveIntermediateResults    
%token pat_gevVarCovarFromBHHH    
%token pat_gevDebugDataFirstRow    
%token pat_gevDebugDataLastRow    
%token pat_gevStoreDataOnFile    
%token pat_gevBinaryDataFile    
%token pat_gevDumpDrawsOnFile    
%token pat_gevReadDrawsFromFile    
%token pat_gevGenerateActualSample    
%token pat_gevOutputActualSample    
%token pat_gevNormalDrawsFile    
%token pat_gevRectangularDrawsFile    
%token pat_gevRandomDistrib    
%token pat_gevMaxPrimeNumber    
%token pat_gevWarningSign    
%token pat_gevWarningLowDraws    
%token pat_gevMissingValue    
%token pat_gevGenerateFilesForDenis    
%token pat_gevGenerateGnuplotFile    
%token pat_gevGeneratePythonFile    
%token pat_gevPythonFileWithEstimatedParam
%token pat_gevFileForDenis    
%token pat_gevAutomaticScalingOfLinearUtility    
%token pat_gevInverseIteration    
%token pat_gevSeed    
%token pat_gevOne    
%token pat_gevMinimumMu    
%token pat_gevSummaryParameters    
%token pat_gevSummaryFile    
%token pat_gevStopFileName    
%token pat_gevCheckDerivatives    
%token pat_gevBufferSize    
%token pat_gevDataFileDisplayStep    
%token pat_gevTtestThreshold    
%token pat_gevGlobal    
%token pat_gevAnalGrad    
%token pat_gevAnalHess    
%token pat_gevCheapF    
%token pat_gevFactSec    
%token pat_gevTermCode    
%token pat_gevTypx    
%token pat_gevTypF    
%token pat_gevFDigits    
%token pat_gevGradTol    
%token pat_gevMaxStep    
%token pat_gevItnLimit    
%token pat_gevDelta    
%token pat_gevAlgo    
%token pat_gevScreenPrintLevel    
%token pat_gevLogFilePrintLevel    
%token pat_gevGeneratedGroups    
%token pat_gevGeneratedData    
%token pat_gevGeneratedAttr    
%token pat_gevGeneratedAlt    
%token pat_gevSubSampleLevel    
%token pat_gevSubSampleBasis    
%token pat_gevComputeLastHessian    
%token pat_gevEigenvalueThreshold    
%token pat_gevNonParamPlotRes    
%token pat_gevNonParamPlotMaxY    
%token pat_gevNonParamPlotXSizeCm    
%token pat_gevNonParamPlotYSizeCm    
%token pat_gevNonParamPlotMinXSizeCm    
%token pat_gevNonParamPlotMinYSizeCm    
%token pat_svdMaxIter    
%token pat_HieLoWSection
%token pat_hieMultinomial    
%token pat_hieTruncStructUtil    
%token pat_hieUpdateHessien    
%token pat_hieDateInLog    
%token pat_LogitKernelFortranSection
%token pat_bolducMaxAlts    
%token pat_bolducMaxFact    
%token pat_bolducMaxNVar    
%token pat_NewtonLikeSection
%token pat_StepSecondIndividual    
%token pat_NLgWeight    
%token pat_NLhWeight    
%token pat_TointSteihaugSection
%token pat_TSFractionGradientRequired    
%token pat_TSExpTheta    
%token pat_cfsqpSection
%token pat_cfsqpMode    
%token pat_cfsqpIprint    
%token pat_cfsqpMaxIter    
%token pat_cfsqpEps    
%token pat_cfsqpEpsEqn    
%token pat_cfsqpUdelta    
%token pat_dfoSection
%token pat_dfoAddToLWRK    
%token pat_dfoAddToLIWRK    
%token pat_dfoMaxFunEval    
%token pat_donlp2Section
%token pat_donlp2Epsx    
%token pat_donlp2Delmin    
%token pat_donlp2Smallw    
%token pat_donlp2Epsdif    
%token pat_donlp2NReset    
%token pat_solvoptSection
%token pat_solvoptMaxIter    
%token pat_solvoptDisplay    
%token pat_solvoptErrorArgument    
%token pat_solvoptErrorFunction    

%token patEQUAL
%token patOB
%token patCB
		            
%token patINT
%token patREAL
%token patTIME

%token patNAME
%token patSTRING

%token patPAIR


%type <ftype>    floatParam
%type <itype>    longParam
%type <stype>    stringParam

%start everything

%%

//--------------------------------------------------------------------
// Beginning  grammer rules.
//--------------------------------------------------------------------

everything : sections {
             } 
           ;

sections: section
       | sections section

section: 
   yBasicTrustRegion |
   yCondTrustRegion |
   yConjugateGradient |
   yDefaultValues |
   yFiles |
   yFormule1 |
   yGEV |
   yHieLoW |
   yLogitKernelFortran |
   yNewtonLike |
   yTointSteihaug |
   ycfsqp |
   ydfo |
   ydonlp2 |
   ysolvopt ;
yBasicTrustRegion: pat_BasicTrustRegionSection yBasicTrustRegion_entries 
yBasicTrustRegion_entries : yBasicTrustRegion_entry
        | yBasicTrustRegion_entries yBasicTrustRegion_entry
        ;
yBasicTrustRegion_entry : pat_BTRMaxGcpIter patEQUAL longParam {
  assert (pParameters != NULL) ;
  pParameters->setBTRMaxGcpIter($3) ;
}
|
pat_BTRArmijoBeta1 patEQUAL floatParam {
  assert (pParameters != NULL) ;
  pParameters->setBTRArmijoBeta1($3) ;
}
|
pat_BTRArmijoBeta2 patEQUAL floatParam {
  assert (pParameters != NULL) ;
  pParameters->setBTRArmijoBeta2($3) ;
}
|
pat_BTRStartDraws patEQUAL longParam {
  assert (pParameters != NULL) ;
  pParameters->setBTRStartDraws($3) ;
}
|
pat_BTRIncreaseDraws patEQUAL floatParam {
  assert (pParameters != NULL) ;
  pParameters->setBTRIncreaseDraws($3) ;
}
|
pat_BTREta1 patEQUAL floatParam {
  assert (pParameters != NULL) ;
  pParameters->setBTREta1($3) ;
}
|
pat_BTREta2 patEQUAL floatParam {
  assert (pParameters != NULL) ;
  pParameters->setBTREta2($3) ;
}
|
pat_BTRGamma1 patEQUAL floatParam {
  assert (pParameters != NULL) ;
  pParameters->setBTRGamma1($3) ;
}
|
pat_BTRGamma2 patEQUAL floatParam {
  assert (pParameters != NULL) ;
  pParameters->setBTRGamma2($3) ;
}
|
pat_BTRInitRadius patEQUAL floatParam {
  assert (pParameters != NULL) ;
  pParameters->setBTRInitRadius($3) ;
}
|
pat_BTRIncreaseTRRadius patEQUAL floatParam {
  assert (pParameters != NULL) ;
  pParameters->setBTRIncreaseTRRadius($3) ;
}
|
pat_BTRUnfeasibleCGIterations patEQUAL longParam {
  assert (pParameters != NULL) ;
  pParameters->setBTRUnfeasibleCGIterations($3) ;
}
|
pat_BTRForceExactHessianIfMnl patEQUAL longParam {
  assert (pParameters != NULL) ;
  pParameters->setBTRForceExactHessianIfMnl($3) ;
}
|
pat_BTRExactHessian patEQUAL longParam {
  assert (pParameters != NULL) ;
  pParameters->setBTRExactHessian($3) ;
}
|
pat_BTRCheapHessian patEQUAL longParam {
  assert (pParameters != NULL) ;
  DEBUG_MESSAGE("Set cheapHessian to " << $3) ;
  pParameters->setBTRCheapHessian($3) ;
}
|
pat_BTRQuasiNewtonUpdate patEQUAL longParam {
  assert (pParameters != NULL) ;
  pParameters->setBTRQuasiNewtonUpdate($3) ;
}
|
pat_BTRInitQuasiNewtonWithTrueHessian patEQUAL longParam {
  assert (pParameters != NULL) ;
  pParameters->setBTRInitQuasiNewtonWithTrueHessian($3) ;
}
|
pat_BTRInitQuasiNewtonWithBHHH patEQUAL longParam {
  assert (pParameters != NULL) ;
  pParameters->setBTRInitQuasiNewtonWithBHHH($3) ;
}
|
pat_BTRMaxIter patEQUAL longParam {
  assert (pParameters != NULL) ;
  pParameters->setBTRMaxIter($3) ;
}
|
pat_BTRTypf patEQUAL floatParam {
  assert (pParameters != NULL) ;
  pParameters->setBTRTypf($3) ;
}
|
pat_BTRTolerance patEQUAL floatParam {
  assert (pParameters != NULL) ;
  pParameters->setBTRTolerance($3) ;
}
|
pat_BTRMaxTRRadius patEQUAL floatParam {
  assert (pParameters != NULL) ;
  pParameters->setBTRMaxTRRadius($3) ;
}
|
pat_BTRMinTRRadius patEQUAL floatParam {
  assert (pParameters != NULL) ;
  pParameters->setBTRMinTRRadius($3) ;
}
|
pat_BTRUsePreconditioner patEQUAL longParam {
  assert (pParameters != NULL) ;
  pParameters->setBTRUsePreconditioner($3) ;
}
|
pat_BTRSingularityThreshold patEQUAL floatParam {
  assert (pParameters != NULL) ;
  pParameters->setBTRSingularityThreshold($3) ;
}
|
pat_BTRKappaEpp patEQUAL floatParam {
  assert (pParameters != NULL) ;
  pParameters->setBTRKappaEpp($3) ;
}
|
pat_BTRKappaLbs patEQUAL floatParam {
  assert (pParameters != NULL) ;
  pParameters->setBTRKappaLbs($3) ;
}
|
pat_BTRKappaUbs patEQUAL floatParam {
  assert (pParameters != NULL) ;
  pParameters->setBTRKappaUbs($3) ;
}
|
pat_BTRKappaFrd patEQUAL floatParam {
  assert (pParameters != NULL) ;
  pParameters->setBTRKappaFrd($3) ;
}
|
pat_BTRSignificantDigits patEQUAL longParam {
  assert (pParameters != NULL) ;
  pParameters->setBTRSignificantDigits($3) ;
}
;
yCondTrustRegion: pat_CondTrustRegionSection yCondTrustRegion_entries 
yCondTrustRegion_entries : yCondTrustRegion_entry
        | yCondTrustRegion_entries yCondTrustRegion_entry
        ;
yCondTrustRegion_entry : pat_CTRAETA0 patEQUAL floatParam {
  assert (pParameters != NULL) ;
  pParameters->setCTRAETA0($3) ;
}
|
pat_CTRAETA1 patEQUAL floatParam {
  assert (pParameters != NULL) ;
  pParameters->setCTRAETA1($3) ;
}
|
pat_CTRAETA2 patEQUAL floatParam {
  assert (pParameters != NULL) ;
  pParameters->setCTRAETA2($3) ;
}
|
pat_CTRAGAMMA1 patEQUAL floatParam {
  assert (pParameters != NULL) ;
  pParameters->setCTRAGAMMA1($3) ;
}
|
pat_CTRAGAMMA2 patEQUAL floatParam {
  assert (pParameters != NULL) ;
  pParameters->setCTRAGAMMA2($3) ;
}
|
pat_CTRAEPSILONC patEQUAL floatParam {
  assert (pParameters != NULL) ;
  pParameters->setCTRAEPSILONC($3) ;
}
|
pat_CTRAALPHA patEQUAL floatParam {
  assert (pParameters != NULL) ;
  pParameters->setCTRAALPHA($3) ;
}
|
pat_CTRAMU patEQUAL longParam {
  assert (pParameters != NULL) ;
  pParameters->setCTRAMU($3) ;
}
|
pat_CTRAMAXNBRFUNCTEVAL patEQUAL longParam {
  assert (pParameters != NULL) ;
  pParameters->setCTRAMAXNBRFUNCTEVAL($3) ;
}
|
pat_CTRAMAXLENGTH patEQUAL longParam {
  assert (pParameters != NULL) ;
  pParameters->setCTRAMAXLENGTH($3) ;
}
|
pat_CTRAMAXDATA patEQUAL longParam {
  assert (pParameters != NULL) ;
  pParameters->setCTRAMAXDATA($3) ;
}
|
pat_CTRANBROFBESTPTS patEQUAL longParam {
  assert (pParameters != NULL) ;
  pParameters->setCTRANBROFBESTPTS($3) ;
}
|
pat_CTRAPOWER patEQUAL floatParam {
  assert (pParameters != NULL) ;
  pParameters->setCTRAPOWER($3) ;
}
|
pat_CTRAMAXRAD patEQUAL longParam {
  assert (pParameters != NULL) ;
  pParameters->setCTRAMAXRAD($3) ;
}
|
pat_CTRAMINRAD patEQUAL floatParam {
  assert (pParameters != NULL) ;
  pParameters->setCTRAMINRAD($3) ;
}
|
pat_CTRAUPPERBOUND patEQUAL floatParam {
  assert (pParameters != NULL) ;
  pParameters->setCTRAUPPERBOUND($3) ;
}
|
pat_CTRALOWERBOUND patEQUAL floatParam {
  assert (pParameters != NULL) ;
  pParameters->setCTRALOWERBOUND($3) ;
}
|
pat_CTRAGAMMA3 patEQUAL floatParam {
  assert (pParameters != NULL) ;
  pParameters->setCTRAGAMMA3($3) ;
}
|
pat_CTRAGAMMA4 patEQUAL floatParam {
  assert (pParameters != NULL) ;
  pParameters->setCTRAGAMMA4($3) ;
}
|
pat_CTRACOEFVALID patEQUAL floatParam {
  assert (pParameters != NULL) ;
  pParameters->setCTRACOEFVALID($3) ;
}
|
pat_CTRACOEFGEN patEQUAL floatParam {
  assert (pParameters != NULL) ;
  pParameters->setCTRACOEFGEN($3) ;
}
|
pat_CTRAEPSERROR patEQUAL floatParam {
  assert (pParameters != NULL) ;
  pParameters->setCTRAEPSERROR($3) ;
}
|
pat_CTRAEPSPOINT patEQUAL floatParam {
  assert (pParameters != NULL) ;
  pParameters->setCTRAEPSPOINT($3) ;
}
|
pat_CTRACOEFNORM patEQUAL floatParam {
  assert (pParameters != NULL) ;
  pParameters->setCTRACOEFNORM($3) ;
}
|
pat_CTRAMINSTEP patEQUAL floatParam {
  assert (pParameters != NULL) ;
  pParameters->setCTRAMINSTEP($3) ;
}
|
pat_CTRAMINPIVOTVALUE patEQUAL floatParam {
  assert (pParameters != NULL) ;
  pParameters->setCTRAMINPIVOTVALUE($3) ;
}
|
pat_CTRAGOODPIVOTVALUE patEQUAL floatParam {
  assert (pParameters != NULL) ;
  pParameters->setCTRAGOODPIVOTVALUE($3) ;
}
|
pat_CTRAFINEPS patEQUAL floatParam {
  assert (pParameters != NULL) ;
  pParameters->setCTRAFINEPS($3) ;
}
|
pat_CTRAFINEPSREL patEQUAL floatParam {
  assert (pParameters != NULL) ;
  pParameters->setCTRAFINEPSREL($3) ;
}
|
pat_CTRACHECKEPS patEQUAL floatParam {
  assert (pParameters != NULL) ;
  pParameters->setCTRACHECKEPS($3) ;
}
|
pat_CTRACHECKTESTEPS patEQUAL floatParam {
  assert (pParameters != NULL) ;
  pParameters->setCTRACHECKTESTEPS($3) ;
}
|
pat_CTRACHECKTESTEPSREL patEQUAL floatParam {
  assert (pParameters != NULL) ;
  pParameters->setCTRACHECKTESTEPSREL($3) ;
}
|
pat_CTRAVALMINGAUSS patEQUAL floatParam {
  assert (pParameters != NULL) ;
  pParameters->setCTRAVALMINGAUSS($3) ;
}
|
pat_CTRAFACTOFPOND patEQUAL floatParam {
  assert (pParameters != NULL) ;
  pParameters->setCTRAFACTOFPOND($3) ;
}
;
yConjugateGradient: pat_ConjugateGradientSection yConjugateGradient_entries 
yConjugateGradient_entries : yConjugateGradient_entry
        | yConjugateGradient_entries yConjugateGradient_entry
        ;
yConjugateGradient_entry : pat_Precond patEQUAL longParam {
  assert (pParameters != NULL) ;
  pParameters->setPrecond($3) ;
}
|
pat_Epsilon patEQUAL floatParam {
  assert (pParameters != NULL) ;
  pParameters->setEpsilon($3) ;
}
|
pat_CondLimit patEQUAL floatParam {
  assert (pParameters != NULL) ;
  pParameters->setCondLimit($3) ;
}
|
pat_PrecResidu patEQUAL floatParam {
  assert (pParameters != NULL) ;
  pParameters->setPrecResidu($3) ;
}
|
pat_MaxCGIter patEQUAL longParam {
  assert (pParameters != NULL) ;
  pParameters->setMaxCGIter($3) ;
}
|
pat_TolSchnabelEskow patEQUAL floatParam {
  assert (pParameters != NULL) ;
  pParameters->setTolSchnabelEskow($3) ;
}
;
yDefaultValues: pat_DefaultValuesSection yDefaultValues_entries 
yDefaultValues_entries : yDefaultValues_entry
        | yDefaultValues_entries yDefaultValues_entry
        ;
yDefaultValues_entry : pat_MaxIter patEQUAL longParam {
  assert (pParameters != NULL) ;
  pParameters->setMaxIter($3) ;
}
|
pat_InitStep patEQUAL floatParam {
  assert (pParameters != NULL) ;
  pParameters->setInitStep($3) ;
}
|
pat_MinStep patEQUAL floatParam {
  assert (pParameters != NULL) ;
  pParameters->setMinStep($3) ;
}
|
pat_MaxEval patEQUAL longParam {
  assert (pParameters != NULL) ;
  pParameters->setMaxEval($3) ;
}
|
pat_NbrRun patEQUAL longParam {
  assert (pParameters != NULL) ;
  pParameters->setNbrRun($3) ;
}
|
pat_MaxStep patEQUAL floatParam {
  assert (pParameters != NULL) ;
  pParameters->setMaxStep($3) ;
}
|
pat_AlphaProba patEQUAL floatParam {
  assert (pParameters != NULL) ;
  pParameters->setAlphaProba($3) ;
}
|
pat_StepReduc patEQUAL floatParam {
  assert (pParameters != NULL) ;
  pParameters->setStepReduc($3) ;
}
|
pat_StepIncr patEQUAL floatParam {
  assert (pParameters != NULL) ;
  pParameters->setStepIncr($3) ;
}
|
pat_ExpectedImprovement patEQUAL floatParam {
  assert (pParameters != NULL) ;
  pParameters->setExpectedImprovement($3) ;
}
|
pat_AllowPremUnsucc patEQUAL longParam {
  assert (pParameters != NULL) ;
  pParameters->setAllowPremUnsucc($3) ;
}
|
pat_PrematureStart patEQUAL floatParam {
  assert (pParameters != NULL) ;
  pParameters->setPrematureStart($3) ;
}
|
pat_PrematureStep patEQUAL floatParam {
  assert (pParameters != NULL) ;
  pParameters->setPrematureStep($3) ;
}
|
pat_MaxUnsuccIter patEQUAL longParam {
  assert (pParameters != NULL) ;
  pParameters->setMaxUnsuccIter($3) ;
}
|
pat_NormWeight patEQUAL floatParam {
  assert (pParameters != NULL) ;
  pParameters->setNormWeight($3) ;
}
;
yFiles: pat_FilesSection yFiles_entries 
yFiles_entries : yFiles_entry
        | yFiles_entries yFiles_entry
        ;
yFiles_entry : pat_InputDirectory patEQUAL stringParam {
  assert (pParameters != NULL) ;
  pParameters->setInputDirectory(*$3) ;
  DELETE_PTR($3) ;
}
|
pat_OutputDirectory patEQUAL stringParam {
  assert (pParameters != NULL) ;
  pParameters->setOutputDirectory(*$3) ;
  DELETE_PTR($3) ;
}
|
pat_TmpDirectory patEQUAL stringParam {
  assert (pParameters != NULL) ;
  pParameters->setTmpDirectory(*$3) ;
  DELETE_PTR($3) ;
}
|
pat_FunctionEvalExec patEQUAL stringParam {
  assert (pParameters != NULL) ;
  pParameters->setFunctionEvalExec(*$3) ;
  DELETE_PTR($3) ;
}
|
pat_jonSimulator patEQUAL stringParam {
  assert (pParameters != NULL) ;
  pParameters->setjonSimulator(*$3) ;
  DELETE_PTR($3) ;
}
|
pat_CandidateFile patEQUAL stringParam {
  assert (pParameters != NULL) ;
  pParameters->setCandidateFile(*$3) ;
  DELETE_PTR($3) ;
}
|
pat_ResultFile patEQUAL stringParam {
  assert (pParameters != NULL) ;
  pParameters->setResultFile(*$3) ;
  DELETE_PTR($3) ;
}
|
pat_OutsifFile patEQUAL stringParam {
  assert (pParameters != NULL) ;
  pParameters->setOutsifFile(*$3) ;
  DELETE_PTR($3) ;
}
|
pat_LogFile patEQUAL stringParam {
  assert (pParameters != NULL) ;
  pParameters->setLogFile(*$3) ;
  DELETE_PTR($3) ;
}
|
pat_ProblemsFile patEQUAL stringParam {
  assert (pParameters != NULL) ;
  pParameters->setProblemsFile(*$3) ;
  DELETE_PTR($3) ;
}
|
pat_MITSIMorigin patEQUAL stringParam {
  assert (pParameters != NULL) ;
  pParameters->setMITSIMorigin(*$3) ;
  DELETE_PTR($3) ;
}
|
pat_MITSIMinformation patEQUAL stringParam {
  assert (pParameters != NULL) ;
  pParameters->setMITSIMinformation(*$3) ;
  DELETE_PTR($3) ;
}
|
pat_MITSIMtravelTime patEQUAL stringParam {
  assert (pParameters != NULL) ;
  pParameters->setMITSIMtravelTime(*$3) ;
  DELETE_PTR($3) ;
}
|
pat_MITSIMexec patEQUAL stringParam {
  assert (pParameters != NULL) ;
  pParameters->setMITSIMexec(*$3) ;
  DELETE_PTR($3) ;
}
;
yFormule1: pat_Formule1Section yFormule1_entries 
yFormule1_entries : yFormule1_entry
        | yFormule1_entries yFormule1_entry
        ;
yFormule1_entry : pat_AugmentationStep patEQUAL floatParam {
  assert (pParameters != NULL) ;
  pParameters->setAugmentationStep($3) ;
}
|
pat_ReductionStep patEQUAL floatParam {
  assert (pParameters != NULL) ;
  pParameters->setReductionStep($3) ;
}
|
pat_SubSpaceMaxIter patEQUAL longParam {
  assert (pParameters != NULL) ;
  pParameters->setSubSpaceMaxIter($3) ;
}
|
pat_SubSpaceConsecutiveFailure patEQUAL longParam {
  assert (pParameters != NULL) ;
  pParameters->setSubSpaceConsecutiveFailure($3) ;
}
|
pat_WarmUpnbre patEQUAL longParam {
  assert (pParameters != NULL) ;
  pParameters->setWarmUpnbre($3) ;
}
;
yGEV: pat_GEVSection yGEV_entries 
yGEV_entries : yGEV_entry
        | yGEV_entries yGEV_entry
        ;
yGEV_entry : pat_gevInputDirectory patEQUAL stringParam {
  assert (pParameters != NULL) ;
  pParameters->setgevInputDirectory(*$3) ;
  DELETE_PTR($3) ;
}
|
pat_gevOutputDirectory patEQUAL stringParam {
  assert (pParameters != NULL) ;
  pParameters->setgevOutputDirectory(*$3) ;
  DELETE_PTR($3) ;
}
|
pat_gevWorkingDirectory patEQUAL stringParam {
  assert (pParameters != NULL) ;
  pParameters->setgevWorkingDirectory(*$3) ;
  DELETE_PTR($3) ;
}
|
pat_gevSignificantDigitsParameters patEQUAL longParam {
  assert (pParameters != NULL) ;
  pParameters->setgevSignificantDigitsParameters($3) ;
}
|
pat_gevDecimalDigitsTTest patEQUAL longParam {
  assert (pParameters != NULL) ;
  pParameters->setgevDecimalDigitsTTest($3) ;
}
|
pat_gevDecimalDigitsStats patEQUAL longParam {
  assert (pParameters != NULL) ;
  pParameters->setgevDecimalDigitsStats($3) ;
}
|
pat_gevForceScientificNotation patEQUAL longParam {
  assert (pParameters != NULL) ;
  pParameters->setgevForceScientificNotation($3) ;
}
|
pat_gevSingularValueThreshold patEQUAL floatParam {
  assert (pParameters != NULL) ;
  pParameters->setgevSingularValueThreshold($3) ;
}
|
pat_gevPrintVarCovarAsList patEQUAL longParam {
  assert (pParameters != NULL) ;
  pParameters->setgevPrintVarCovarAsList($3) ;
}
|
pat_gevPrintVarCovarAsMatrix patEQUAL longParam {
  assert (pParameters != NULL) ;
  pParameters->setgevPrintVarCovarAsMatrix($3) ;
}
|
pat_gevPrintPValue patEQUAL longParam {
  assert (pParameters != NULL) ;
  pParameters->setgevPrintPValue($3) ;
}
|
pat_gevNumberOfThreads patEQUAL longParam {
  assert (pParameters != NULL) ;
  pParameters->setgevNumberOfThreads($3) ;
}
|
pat_gevSaveIntermediateResults patEQUAL longParam {
  assert (pParameters != NULL) ;
  pParameters->setgevSaveIntermediateResults($3) ;
}
|
pat_gevVarCovarFromBHHH patEQUAL longParam {
  assert (pParameters != NULL) ;
  pParameters->setgevVarCovarFromBHHH($3) ;
}
|
pat_gevDebugDataFirstRow patEQUAL longParam {
  assert (pParameters != NULL) ;
  pParameters->setgevDebugDataFirstRow($3) ;
}
|
pat_gevDebugDataLastRow patEQUAL longParam {
  assert (pParameters != NULL) ;
  pParameters->setgevDebugDataLastRow($3) ;
}
|
pat_gevStoreDataOnFile patEQUAL longParam {
  assert (pParameters != NULL) ;
  pParameters->setgevStoreDataOnFile($3) ;
}
|
pat_gevBinaryDataFile patEQUAL stringParam {
  assert (pParameters != NULL) ;
  pParameters->setgevBinaryDataFile(*$3) ;
  DELETE_PTR($3) ;
}
|
pat_gevDumpDrawsOnFile patEQUAL longParam {
  assert (pParameters != NULL) ;
  pParameters->setgevDumpDrawsOnFile($3) ;
}
|
pat_gevReadDrawsFromFile patEQUAL longParam {
  assert (pParameters != NULL) ;
  pParameters->setgevReadDrawsFromFile($3) ;
}
|
pat_gevGenerateActualSample patEQUAL longParam {
  assert (pParameters != NULL) ;
  pParameters->setgevGenerateActualSample($3) ;
}
|
pat_gevOutputActualSample patEQUAL stringParam {
  assert (pParameters != NULL) ;
  pParameters->setgevOutputActualSample(*$3) ;
  DELETE_PTR($3) ;
}
|
pat_gevNormalDrawsFile patEQUAL stringParam {
  assert (pParameters != NULL) ;
  pParameters->setgevNormalDrawsFile(*$3) ;
  DELETE_PTR($3) ;
}
|
pat_gevRectangularDrawsFile patEQUAL stringParam {
  assert (pParameters != NULL) ;
  pParameters->setgevRectangularDrawsFile(*$3) ;
  DELETE_PTR($3) ;
}
|
pat_gevRandomDistrib patEQUAL stringParam {
  assert (pParameters != NULL) ;
  pParameters->setgevRandomDistrib(*$3) ;
  DELETE_PTR($3) ;
}
|
pat_gevMaxPrimeNumber patEQUAL longParam {
  assert (pParameters != NULL) ;
  pParameters->setgevMaxPrimeNumber($3) ;
}
|
pat_gevWarningSign patEQUAL stringParam {
  assert (pParameters != NULL) ;
  pParameters->setgevWarningSign(*$3) ;
  DELETE_PTR($3) ;
}
|
pat_gevWarningLowDraws patEQUAL longParam {
  assert (pParameters != NULL) ;
  pParameters->setgevWarningLowDraws($3) ;
}
|
pat_gevMissingValue patEQUAL floatParam {
  assert (pParameters != NULL) ;
  pParameters->setgevMissingValue($3) ;
}
|
pat_gevGenerateFilesForDenis patEQUAL longParam {
  assert (pParameters != NULL) ;
  pParameters->setgevGenerateFilesForDenis($3) ;
}
|
pat_gevGenerateGnuplotFile patEQUAL longParam {
  assert (pParameters != NULL) ;
  pParameters->setgevGenerateGnuplotFile($3) ;
}
|
pat_gevGeneratePythonFile patEQUAL longParam {
  assert (pParameters != NULL) ;
  pParameters->setgevGeneratePythonFile($3) ;
}
|
pat_gevPythonFileWithEstimatedParam patEQUAL longParam {
  assert (pParameters != NULL) ;
  pParameters->setgevPythonFileWithEstimatedParam($3) ;
}
|
pat_gevFileForDenis patEQUAL stringParam {
  assert (pParameters != NULL) ;
  pParameters->setgevFileForDenis(*$3) ;
  DELETE_PTR($3) ;
}
|
pat_gevAutomaticScalingOfLinearUtility patEQUAL longParam {
  assert (pParameters != NULL) ;
  pParameters->setgevAutomaticScalingOfLinearUtility($3) ;
}
|
pat_gevInverseIteration patEQUAL longParam {
  assert (pParameters != NULL) ;
  pParameters->setgevInverseIteration($3) ;
}
|
pat_gevSeed patEQUAL longParam {
  assert (pParameters != NULL) ;
  pParameters->setgevSeed($3) ;
}
|
pat_gevOne patEQUAL stringParam {
  assert (pParameters != NULL) ;
  pParameters->setgevOne(*$3) ;
  DELETE_PTR($3) ;
}
|
pat_gevMinimumMu patEQUAL floatParam {
  assert (pParameters != NULL) ;
  pParameters->setgevMinimumMu($3) ;
}
|
pat_gevSummaryParameters patEQUAL stringParam {
  assert (pParameters != NULL) ;
  pParameters->setgevSummaryParameters(*$3) ;
  DELETE_PTR($3) ;
}
|
pat_gevSummaryFile patEQUAL stringParam {
  assert (pParameters != NULL) ;
  pParameters->setgevSummaryFile(*$3) ;
  DELETE_PTR($3) ;
}
|
pat_gevStopFileName patEQUAL stringParam {
  assert (pParameters != NULL) ;
  pParameters->setgevStopFileName(*$3) ;
  DELETE_PTR($3) ;
}
|
pat_gevCheckDerivatives patEQUAL longParam {
  assert (pParameters != NULL) ;
  pParameters->setgevCheckDerivatives($3) ;
}
|
pat_gevBufferSize patEQUAL longParam {
  assert (pParameters != NULL) ;
  pParameters->setgevBufferSize($3) ;
}
|
pat_gevDataFileDisplayStep patEQUAL longParam {
  assert (pParameters != NULL) ;
  pParameters->setgevDataFileDisplayStep($3) ;
}
|
pat_gevTtestThreshold patEQUAL floatParam {
  assert (pParameters != NULL) ;
  pParameters->setgevTtestThreshold($3) ;
}
|
pat_gevGlobal patEQUAL longParam {
  assert (pParameters != NULL) ;
  pParameters->setgevGlobal($3) ;
}
|
pat_gevAnalGrad patEQUAL longParam {
  assert (pParameters != NULL) ;
  pParameters->setgevAnalGrad($3) ;
}
|
pat_gevAnalHess patEQUAL longParam {
  assert (pParameters != NULL) ;
  pParameters->setgevAnalHess($3) ;
}
|
pat_gevCheapF patEQUAL longParam {
  assert (pParameters != NULL) ;
  pParameters->setgevCheapF($3) ;
}
|
pat_gevFactSec patEQUAL longParam {
  assert (pParameters != NULL) ;
  pParameters->setgevFactSec($3) ;
}
|
pat_gevTermCode patEQUAL longParam {
  assert (pParameters != NULL) ;
  pParameters->setgevTermCode($3) ;
}
|
pat_gevTypx patEQUAL longParam {
  assert (pParameters != NULL) ;
  pParameters->setgevTypx($3) ;
}
|
pat_gevTypF patEQUAL floatParam {
  assert (pParameters != NULL) ;
  pParameters->setgevTypF($3) ;
}
|
pat_gevFDigits patEQUAL longParam {
  assert (pParameters != NULL) ;
  pParameters->setgevFDigits($3) ;
}
|
pat_gevGradTol patEQUAL floatParam {
  assert (pParameters != NULL) ;
  pParameters->setgevGradTol($3) ;
}
|
pat_gevMaxStep patEQUAL floatParam {
  assert (pParameters != NULL) ;
  pParameters->setgevMaxStep($3) ;
}
|
pat_gevItnLimit patEQUAL longParam {
  assert (pParameters != NULL) ;
  pParameters->setgevItnLimit($3) ;
}
|
pat_gevDelta patEQUAL floatParam {
  assert (pParameters != NULL) ;
  pParameters->setgevDelta($3) ;
}
|
pat_gevAlgo patEQUAL stringParam {
  assert (pParameters != NULL) ;
  pParameters->setgevAlgo(*$3) ;
  DELETE_PTR($3) ;
}
|
pat_gevScreenPrintLevel patEQUAL longParam {
  assert (pParameters != NULL) ;
  pParameters->setgevScreenPrintLevel($3) ;
}
|
pat_gevLogFilePrintLevel patEQUAL longParam {
  assert (pParameters != NULL) ;
  pParameters->setgevLogFilePrintLevel($3) ;
}
|
pat_gevGeneratedGroups patEQUAL longParam {
  assert (pParameters != NULL) ;
  pParameters->setgevGeneratedGroups($3) ;
}
|
pat_gevGeneratedData patEQUAL longParam {
  assert (pParameters != NULL) ;
  pParameters->setgevGeneratedData($3) ;
}
|
pat_gevGeneratedAttr patEQUAL longParam {
  assert (pParameters != NULL) ;
  pParameters->setgevGeneratedAttr($3) ;
}
|
pat_gevGeneratedAlt patEQUAL longParam {
  assert (pParameters != NULL) ;
  pParameters->setgevGeneratedAlt($3) ;
}
|
pat_gevSubSampleLevel patEQUAL longParam {
  assert (pParameters != NULL) ;
  pParameters->setgevSubSampleLevel($3) ;
}
|
pat_gevSubSampleBasis patEQUAL longParam {
  assert (pParameters != NULL) ;
  pParameters->setgevSubSampleBasis($3) ;
}
|
pat_gevComputeLastHessian patEQUAL longParam {
  assert (pParameters != NULL) ;
  pParameters->setgevComputeLastHessian($3) ;
}
|
pat_gevEigenvalueThreshold patEQUAL floatParam {
  assert (pParameters != NULL) ;
  pParameters->setgevEigenvalueThreshold($3) ;
}
|
pat_gevNonParamPlotRes patEQUAL longParam {
  assert (pParameters != NULL) ;
  pParameters->setgevNonParamPlotRes($3) ;
}
|
pat_gevNonParamPlotMaxY patEQUAL floatParam {
  assert (pParameters != NULL) ;
  pParameters->setgevNonParamPlotMaxY($3) ;
}
|
pat_gevNonParamPlotXSizeCm patEQUAL longParam {
  assert (pParameters != NULL) ;
  pParameters->setgevNonParamPlotXSizeCm($3) ;
}
|
pat_gevNonParamPlotYSizeCm patEQUAL longParam {
  assert (pParameters != NULL) ;
  pParameters->setgevNonParamPlotYSizeCm($3) ;
}
|
pat_gevNonParamPlotMinXSizeCm patEQUAL floatParam {
  assert (pParameters != NULL) ;
  pParameters->setgevNonParamPlotMinXSizeCm($3) ;
}
|
pat_gevNonParamPlotMinYSizeCm patEQUAL floatParam {
  assert (pParameters != NULL) ;
  pParameters->setgevNonParamPlotMinYSizeCm($3) ;
}
|
pat_svdMaxIter patEQUAL longParam {
  assert (pParameters != NULL) ;
  pParameters->setsvdMaxIter($3) ;
}
;
yHieLoW: pat_HieLoWSection yHieLoW_entries 
yHieLoW_entries : yHieLoW_entry
        | yHieLoW_entries yHieLoW_entry
        ;
yHieLoW_entry : pat_hieMultinomial patEQUAL longParam {
  assert (pParameters != NULL) ;
  pParameters->sethieMultinomial($3) ;
}
|
pat_hieTruncStructUtil patEQUAL longParam {
  assert (pParameters != NULL) ;
  pParameters->sethieTruncStructUtil($3) ;
}
|
pat_hieUpdateHessien patEQUAL longParam {
  assert (pParameters != NULL) ;
  pParameters->sethieUpdateHessien($3) ;
}
|
pat_hieDateInLog patEQUAL longParam {
  assert (pParameters != NULL) ;
  pParameters->sethieDateInLog($3) ;
}
;
yLogitKernelFortran: pat_LogitKernelFortranSection yLogitKernelFortran_entries 
yLogitKernelFortran_entries : yLogitKernelFortran_entry
        | yLogitKernelFortran_entries yLogitKernelFortran_entry
        ;
yLogitKernelFortran_entry : pat_bolducMaxAlts patEQUAL longParam {
  assert (pParameters != NULL) ;
  pParameters->setbolducMaxAlts($3) ;
}
|
pat_bolducMaxFact patEQUAL longParam {
  assert (pParameters != NULL) ;
  pParameters->setbolducMaxFact($3) ;
}
|
pat_bolducMaxNVar patEQUAL longParam {
  assert (pParameters != NULL) ;
  pParameters->setbolducMaxNVar($3) ;
}
;
yNewtonLike: pat_NewtonLikeSection yNewtonLike_entries 
yNewtonLike_entries : yNewtonLike_entry
        | yNewtonLike_entries yNewtonLike_entry
        ;
yNewtonLike_entry : pat_StepSecondIndividual patEQUAL floatParam {
  assert (pParameters != NULL) ;
  pParameters->setStepSecondIndividual($3) ;
}
|
pat_NLgWeight patEQUAL floatParam {
  assert (pParameters != NULL) ;
  pParameters->setNLgWeight($3) ;
}
|
pat_NLhWeight patEQUAL floatParam {
  assert (pParameters != NULL) ;
  pParameters->setNLhWeight($3) ;
}
;
yTointSteihaug: pat_TointSteihaugSection yTointSteihaug_entries 
yTointSteihaug_entries : yTointSteihaug_entry
        | yTointSteihaug_entries yTointSteihaug_entry
        ;
yTointSteihaug_entry : pat_TSFractionGradientRequired patEQUAL floatParam {
  assert (pParameters != NULL) ;
  pParameters->setTSFractionGradientRequired($3) ;
}
|
pat_TSExpTheta patEQUAL floatParam {
  assert (pParameters != NULL) ;
  pParameters->setTSExpTheta($3) ;
}
;
ycfsqp: pat_cfsqpSection ycfsqp_entries 
ycfsqp_entries : ycfsqp_entry
        | ycfsqp_entries ycfsqp_entry
        ;
ycfsqp_entry : pat_cfsqpMode patEQUAL longParam {
  assert (pParameters != NULL) ;
  pParameters->setcfsqpMode($3) ;
}
|
pat_cfsqpIprint patEQUAL longParam {
  assert (pParameters != NULL) ;
  pParameters->setcfsqpIprint($3) ;
}
|
pat_cfsqpMaxIter patEQUAL longParam {
  assert (pParameters != NULL) ;
  pParameters->setcfsqpMaxIter($3) ;
}
|
pat_cfsqpEps patEQUAL floatParam {
  assert (pParameters != NULL) ;
  pParameters->setcfsqpEps($3) ;
}
|
pat_cfsqpEpsEqn patEQUAL floatParam {
  assert (pParameters != NULL) ;
  pParameters->setcfsqpEpsEqn($3) ;
}
|
pat_cfsqpUdelta patEQUAL floatParam {
  assert (pParameters != NULL) ;
  pParameters->setcfsqpUdelta($3) ;
}
;
ydfo: pat_dfoSection ydfo_entries 
ydfo_entries : ydfo_entry
        | ydfo_entries ydfo_entry
        ;
ydfo_entry : pat_dfoAddToLWRK patEQUAL longParam {
  assert (pParameters != NULL) ;
  pParameters->setdfoAddToLWRK($3) ;
}
|
pat_dfoAddToLIWRK patEQUAL longParam {
  assert (pParameters != NULL) ;
  pParameters->setdfoAddToLIWRK($3) ;
}
|
pat_dfoMaxFunEval patEQUAL longParam {
  assert (pParameters != NULL) ;
  pParameters->setdfoMaxFunEval($3) ;
}
;
ydonlp2: pat_donlp2Section ydonlp2_entries 
ydonlp2_entries : ydonlp2_entry
        | ydonlp2_entries ydonlp2_entry
        ;
ydonlp2_entry : pat_donlp2Epsx patEQUAL floatParam {
  assert (pParameters != NULL) ;
  pParameters->setdonlp2Epsx($3) ;
}
|
pat_donlp2Delmin patEQUAL floatParam {
  assert (pParameters != NULL) ;
  pParameters->setdonlp2Delmin($3) ;
}
|
pat_donlp2Smallw patEQUAL floatParam {
  assert (pParameters != NULL) ;
  pParameters->setdonlp2Smallw($3) ;
}
|
pat_donlp2Epsdif patEQUAL floatParam {
  assert (pParameters != NULL) ;
  pParameters->setdonlp2Epsdif($3) ;
}
|
pat_donlp2NReset patEQUAL longParam {
  assert (pParameters != NULL) ;
  pParameters->setdonlp2NReset($3) ;
}
;
ysolvopt: pat_solvoptSection ysolvopt_entries 
ysolvopt_entries : ysolvopt_entry
        | ysolvopt_entries ysolvopt_entry
        ;
ysolvopt_entry : pat_solvoptMaxIter patEQUAL longParam {
  assert (pParameters != NULL) ;
  pParameters->setsolvoptMaxIter($3) ;
}
|
pat_solvoptDisplay patEQUAL longParam {
  assert (pParameters != NULL) ;
  pParameters->setsolvoptDisplay($3) ;
}
|
pat_solvoptErrorArgument patEQUAL floatParam {
  assert (pParameters != NULL) ;
  pParameters->setsolvoptErrorArgument($3) ;
}
|
pat_solvoptErrorFunction patEQUAL floatParam {
  assert (pParameters != NULL) ;
  pParameters->setsolvoptErrorFunction($3) ;
}
;

stringParam : patSTRING {
  string* str = new string((scanner.removeDelimeters()));
  $$ = str ;
}

floatParam : patREAL {
  $$ = atof( scanner.value().c_str() );
}
;

longParam: patINT {
  $$ = atoi( scanner.value().c_str() );
}
;
//--------------------------------------------------------------------
// End of basic grammer rules
//--------------------------------------------------------------------

%%

%header{
//--------------------------------------------------------------------
// Following pieces of code will be verbosely copied into the parser.
//--------------------------------------------------------------------

class patParserParam: public patBisonParam {

public:
                                    // ctor with filename argument

  patParserParam( const string& fname_ ) :	
    patBisonParam( fname_.c_str() ) {}
  
                                    // dtor
  virtual ~patParserParam() {}
                                    // Utility functions

  string filename() const { return scanner.filename(); }

  void yyerror( char* msg ) {
    cout << "Call to yyerror" << endl << endl ;
    cerr << *msg;
    cerr << " (" << filename() << ":" << scanner.lineno() << ") ";
    cerr << "Field: <" << scanner.YYText() << ">" << endl;
    exit( 1 );
  }

  int yylex() { return scanner.yylex(); }

  patBoolean parse( patParameters *p ) {
     if ( pParameters ) {
       cerr << "\nError:: cannot parse <";
       cerr << filename() << "> twice" << endl;
       return( patFALSE );
     }
     else {
       ostringstream os;
       os << "Parsing <"
	  << filename() << ">";
       pParameters = p;
       yyparse();
       return( patTRUE );
     }
   }
};

 %}

